# BASH COMPLETION SCRIPT FOR STANDARD_UNIX_NOTES  journal(1)
# Original PASSWORD_STORE version Copyright (C) 2012 - 2014 Jason A. Donenfeld <Jason@zx2c4.com> and
# Brian Mattern <rephorm@rephorm.com>. All Rights Reserved.

# Installed into 
# /usr/share/bash-completion/completions/journal


_journal_complete_entries () {
    if [ -n "$XDG_DATA_DIR"  -a  -z "$NOTESDIR" ] ; then
            # only use $XDG_DATA_DIR if NOTESDIR not set
            NOTESDIR="${XDG_DATA_DIR}/.notes"
    else
            # use NOTESDIR if set else default to ~/.notes
            NOTESDIR="${NOTESDIR:-${HOME}/.notes}"
    fi
    CONFIGFILE="${NOTESDIR}/config"
    INITIAL_NOTEBOOK="${NOTESDIR}/notes"
    DEFAULT_POINTER="${NOTESDIR}/DEFAULT"
    USE_POINTER="${NOTESDIR}/USE"
    JOURNALDIR="${NOTESDIR}/Journal"




    #fixup original password store code to search inside the Journal dir
	prefix="${JOURNALDIR}"

    # code chunk below is fromthe original password store code
	prefix="${prefix%/}/"
	suffix=".gpg"
	autoexpand=${1:-0}

	local IFS=$'\n'
	local items=($(compgen -f $prefix$cur))

	# Remember the value of the first item, to see if it is a directory. If
	# it is a directory, then don't add a space to the completion
	local firstitem=""
	# Use counter, can't use ${#items[@]} as we skip hidden directories
	local i=0

	for item in ${items[@]}; do
		[[ $item =~ /\.[^/]*$ ]] && continue

		# if there is a unique match, and it is a directory with one entry
		# autocomplete the subentry as well (recursively)
		if [[ ${#items[@]} -eq 1 && $autoexpand -eq 1 ]]; then
			while [[ -d $item ]]; do
				local subitems=($(compgen -f "$item/"))
				local filtereditems=( )
				for item2 in "${subitems[@]}"; do
					[[ $item2 =~ /\.[^/]*$ ]] && continue
					filtereditems+=( "$item2" )
				done
				if [[ ${#filtereditems[@]} -eq 1 ]]; then
					item="${filtereditems[0]}"
				else
					break
				fi
			done
		fi

		# append / to directories
		[[ -d $item ]] && item="$item/"

		item="${item%$suffix}"
		COMPREPLY+=("${item#$prefix}")
		if [[ $i -eq 0 ]]; then
			firstitem=$item
		fi
		let i+=1
	done

	# The only time we want to add a space to the end is if there is only
	# one match, and it is not a directory
	if [[ $i -gt 1 || ( $i -eq 1 && -d $firstitem ) ]]; then
		compopt -o nospace
	fi
}


_journal_complete_keys () {
	local IFS=$'\n'
	local GPG=gpg2
	which $GPG >/dev/null || GPG=gpg
	# Extract names and email addresses from gpg --list-keys
	local keys="$($GPG --list-secret-keys --with-colons | cut -d : -f 10 | sort -u | sed '/^$/d')"
	COMPREPLY+=($(compgen -W "${keys}" -- ${cur}))
}

_journal()
{
	COMPREPLY=()
	local cur="${COMP_WORDS[COMP_CWORD]}"
	local commands="config newkey help version ls list show find search grep add insert view cat import rename mv copy  cp rm remove delete edit  ${UNIX_journal_EXTENSION_COMMANDS[*]}"
	if [[ $COMP_CWORD -gt 1 ]]; then
		local lastarg="${COMP_WORDS[$COMP_CWORD-1]}"
		case "${COMP_WORDS[1]}" in
			view|cat|edit|insert|add|cp|copy|mv|rename|rm|remove|delete)
				_journal_complete_entries
				;;
            import)
                ;;
            *)
                ;;
		esac

		# To add completion for an extension command define a function like this:
		# __unix_journal_extension_complete_<COMMAND>() {
		#     COMPREPLY+=($(compgen -W "-o --option" -- ${cur}))
		#     _journal_complete_entries 1
		# }
		#
		# and add the command to the $UNIX_journal_EXTENSION_COMMANDS array
		if [[ " ${UNIX_journal_EXTENSION_COMMANDS[*]} " == *" ${COMP_WORDS[1]} "* ]] && type "__unix_journal_extension_complete_${COMP_WORDS[1]}" &> /dev/null; then
			"__unix_journal_extension_complete_${COMP_WORDS[1]}"
		fi
	else
		COMPREPLY+=($(compgen -W "${commands}" -- ${cur}))
	#	_journal_complete_entries 1
	fi
}


complete -o filenames -F _journal journal

